# H5 五子棋项目技术架构设计文档

> 版本：1.0  
> 适用对象：开发团队、技术评审、架构设计  
> 基于：项目需求规格说明书 v1.0

---

## 目录

1. [架构概述](#架构概述)
2. [设计原则](#设计原则)
3. [系统分层](#系统分层)
4. [核心模块详细设计](#核心模块详细设计)
5. [数据流与状态管理](#数据流与状态管理)
6. [事件与通信机制](#事件与通信机制)
7. [AI 引擎架构](#ai-引擎架构)
8. [渲染与 UI 架构](#渲染与-ui-架构)
9. [存储与序列化](#存储与序列化)
10. [模块加载与依赖管理](#模块加载与依赖管理)
11. [扩展性设计](#扩展性设计)
12. [性能优化策略](#性能优化策略)

---

## 架构概述

### 系统定位
H5 五子棋是一个**纯前端单页应用**，采用**原生 JavaScript + Canvas 2D**技术栈，无需后端服务器，可部署为静态资源。

### 核心设计目标
1. **清晰的职责分离**：数据、逻辑、渲染、服务分层独立
2. **可测试性**：核心模块可独立单元测试，无全局副作用
3. **可扩展性**：新增游戏模式、AI 策略、UI 组件容易插拔
4. **高性能**：60fps 渲染、AI 响应时间符合需求规格
5. **可维护性**：模块化设计、统一编码规范、完善文档

### 技术栈
| 类别 | 技术选型 | 说明 |
|------|-----------|------|
| 语言 | JavaScript ES2020 | 原生 JS，无需编译打包 |
| 渲染 | Canvas 2D API | 高性能图形绘制 |
| 架构 | MVC + 事件驱动 | 职责分离、松耦合 |
| 状态管理 | 中心化 GameState | 单一数据源，不可变更新 |
| 存储 | LocalStorage + JSON | 轻量级本地持久化 |
| 测试 | Vitest / Jest | 单元测试、集成测试 |
| 工具 | ESLint + Prettier | 代码规范、格式化 |

---

## 设计原则

### 1. 单一职责原则（SRP）
每个模块只负责一个明确的功能领域：
- `GameState` 只管理棋盘数据与历史记录
- `RuleEngine` 只负责规则判定与禁手检测
- `AIEngine` 只提供 AI 策略选择与落子计算
- `CanvasRenderer` 只负责视觉渲染

### 2. 开闭原则（OCP）
- 对扩展开放：新增 AI 策略、游戏模式通过配置或插件实现
- 对修改封闭：核心模块接口稳定，避免频繁改动

### 3. 依赖倒置原则（DIP）
- 高层模块不直接依赖低层模块，通过接口/事件解耦
- 示例：`ModeManager` 不直接操作 Canvas，而是发布 `stateChanged` 事件，由 `CanvasRenderer` 订阅

### 4. 最少知识原则（LoD）
- 模块间尽量通过事件总线通信，减少直接引用
- 避免 A → B → C 的链式依赖

---

## 系统分层

```
┌─────────────────────────────────────────────┐
│           Presentation Layer（展示层）        │
│  ┌──────────────────────────────────────┐  │
│  │  CanvasRenderer  HudPanel  Dialog    │  │
│  └──────────────────────────────────────┘  │
└───────────────────┬─────────────────────────┘
                    │ Events / State Sync
┌─────────────────────────────────────────────┐
│          Application Layer（应用层）         │
│  ┌──────────────────────────────────────┐  │
│  │  ModeManager  GameController         │  │
│  └──────────────────────────────────────┘  │
└───────────────────┬─────────────────────────┘
                    │ Calls Logic APIs
┌─────────────────────────────────────────────┐
│            Logic Layer（逻辑层）             │
│  ┌──────────────────────────────────────┐  │
│  │  RuleEngine  AIEngine                │  │
│  └──────────────────────────────────────┘  │
└───────────────────┬─────────────────────────┘
                    │ Operate on Data
┌─────────────────────────────────────────────┐
│            Data Layer（数据层）              │
│  ┌──────────────────────────────────────┐  │
│  │  GameState  MoveHistory              │  │
│  └──────────────────────────────────────┘  │
└─────────────────────────────────────────────┘
┌─────────────────────────────────────────────┐
│           Service Layer（服务层）            │
│  SaveLoadService  ReplayService  Utils      │
└─────────────────────────────────────────────┘
```

### 职责说明
| 层级 | 主要职责 | 代表模块 |
|------|-----------|-----------|
| 展示层 | 用户交互、视觉渲染 | CanvasRenderer, HudPanel |
| 应用层 | 流程控制、模式切换 | ModeManager, GameController |
| 逻辑层 | 规则检测、AI 计算 | RuleEngine, AIEngine |
| 数据层 | 状态管理、历史记录 | GameState, MoveHistory |
| 服务层 | 横向服务（存储、回放） | SaveLoadService, ReplayService |

---

## 核心模块详细设计

### 1. GameState（数据层核心）
**职责**：维护游戏运行时的完整状态

**数据结构**：
```javascript
class GameState {
  constructor() {
    this.boardSize = 15;
    this.board = Array(15).fill().map(() => Array(15).fill(0)); // 0=空, 1=黑, 2=白
    this.currentPlayer = 1;
    this.moveHistory = []; // [{step, player, x, y, timestamp}]
    this.mode = 'PvP'; // PvP | PvE | EvE
    this.settings = {
      forbiddenRules: true,
      aiDifficulty: 'NORMAL',
      blackAI: 'NORMAL',
      whiteAI: 'NORMAL',
      firstPlayer: 1
    };
    this.gameStatus = 'ready'; // ready | playing | finished
    this.winner = null;
    this.startTime = null;
    this.endTime = null;
  }

  // 核心方法
  reset() { /* 重置所有状态 */ }
  applyMove(move) { /* 落子并更新状态 */ }
  undoMove() { /* 撤回最后一步 */ }
  getSnapshot() { /* 返回深拷贝的完整状态，用于存档或回放 */ }
  restoreSnapshot(snapshot) { /* 从快照恢复状态 */ }
  switchPlayer() { /* 切换当前玩家 */ }
  isValidPosition(x, y) { /* 坐标合法性检测 */ }
  getPiece(x, y) { /* 获取指定位置棋子 */ }
  setPiece(x, y, player) { /* 设置指定位置棋子 */ }
}
```

**事件**：
- `state:changed` - 状态发生变化
- `move:applied` - 落子完成
- `move:undone` - 悔棋完成
- `game:started` - 游戏开始
- `game:finished` - 游戏结束

---

### 2. RuleEngine（逻辑层核心）
**职责**：五子棋规则判定、禁手检测、棋型分析

**接口定义**：
```javascript
class RuleEngine {
  constructor(gameState) {
    this.state = gameState;
    this.directions = [
      { dx: 1, dy: 0, name: 'horizontal' },
      { dx: 0, dy: 1, name: 'vertical' },
      { dx: 1, dy: 1, name: 'diagDown' },
      { dx: 1, dy: -1, name: 'diagUp' }
    ];
  }

  // 主要方法
  validateMove(x, y) {
    // 返回：{ valid: boolean, error?: string, forbiddenInfo?: object }
  }

  checkWin(x, y, player) {
    // 返回：{ isWin: boolean, winLine?: [{x, y}], direction?: string }
  }

  detectForbidden(x, y) {
    // 返回：{ isForbidden: boolean, type?: string, details?: object }
  }

  // 辅助方法
  countOpenThrees(x, y, player) { /* 统计活三数量 */ }
  countFours(x, y, player) { /* 统计四的数量（活四+冲四） */ }
  checkLongLine(x, y, player) { /* 检测长连 */ }
  analyzePattern(x, y, dx, dy, player) { /* 分析指定方向棋型 */ }
  getLineSignature(x, y, dx, dy, player, range) { /* 生成线性签名用于模式匹配 */ }
}
```

**禁手检测流程**：
1. 临时在 (x, y) 落子（不修改实际状态）
2. 遍历四个方向，统计活三、活四、长连
3. 根据计数结果判断禁手类型
4. 移除临时落子，返回检测结果

---

### 3. AIEngine（逻辑层核心）
**职责**：AI 策略调度、候选点生成、评分计算

**架构**：
```
AIEngine (总控)
  ├── StrategyFactory (工厂模式)
  │   ├── BeginnerStrategy
  │   ├── NormalStrategy
  │   ├── HardStrategy
  │   └── HellStrategy
  ├── CandidateGenerator (候选点生成器)
  ├── EvaluationService (评分服务)
  │   ├── PatternAnalyzer (棋型识别)
  │   ├── ThreatDetector (威胁检测)
  │   └── ScoreCalculator (分数计算)
  └── SearchEngine (搜索引擎)
      ├── MinimaxSearch
      ├── AlphaBetaSearch
      └── ThreatSpaceSearch
```

**核心接口**：
```javascript
class AIEngine {
  constructor(gameState, ruleEngine) {
    this.state = gameState;
    this.rules = ruleEngine;
    this.strategies = new StrategyFactory();
    this.currentDifficulty = {
      black: 'NORMAL',
      white: 'NORMAL'
    };
  }

  setDifficulty(player, level) {
    // BEGINNER | NORMAL | HARD | HELL
    this.currentDifficulty[player === 1 ? 'black' : 'white'] = level;
  }

  async computeMove(player) {
    // 返回：Promise<{x, y, score?, thinking_time?}>
    const strategy = this.strategies.get(this.currentDifficulty[player === 1 ? 'black' : 'white']);
    return strategy.compute(this.state, player);
  }
}
```

**策略接口**（Strategy Pattern）：
```javascript
class AIStrategy {
  constructor(config) {
    this.name = config.name;
    this.maxDepth = config.maxDepth;
    this.timeout = config.timeout;
  }

  compute(state, player) {
    // 子类实现具体算法
  }

  evaluate(state, player) {
    // 评估局面分数
  }

  generateCandidates(state) {
    // 生成候选落子点
  }
}
```

---

### 4. CanvasRenderer（展示层核心）
**职责**：棋盘与棋子的 Canvas 绘制、坐标转换、视觉特效

**结构**：
```javascript
class CanvasRenderer {
  constructor(canvasId, gameState) {
    this.canvas = document.getElementById(canvasId);
    this.ctx = this.canvas.getContext('2d');
    this.state = gameState;
    
    // 渲染配置
    this.cellSize = 36;
    this.padding = 30;
    this.pieceRadius = 15;
    
    // 特效状态
    this.lastMove = null;
    this.hintMove = null;
    this.forbiddenHighlight = null;
    this.hoverPosition = null;
  }

  render() {
    this.clearCanvas();
    this.drawBoard();
    this.drawStarPoints();
    this.drawPieces();
    this.drawEffects(); // 高亮、提示等特效
  }

  // 坐标转换
  screenToGrid(screenX, screenY) {
    const x = Math.round((screenX - this.padding) / this.cellSize);
    const y = Math.round((screenY - this.padding) / this.cellSize);
    return { x, y };
  }

  gridToScreen(x, y) {
    return {
      x: this.padding + x * this.cellSize,
      y: this.padding + y * this.cellSize
    };
  }

  // 特效方法
  highlightLastMove(move) { /* 金色/粉色光晕 */ }
  showHint(move) { /* 绿色十字标记 */ }
  showForbidden(pos, info) { /* 红色边框+文字 */ }
  animatePlacement(x, y, player) { /* 落子动画 */ }
}
```

---

### 5. ModeManager（应用层核心）
**职责**：游戏模式切换、流程控制、AI 调度

**状态机**：
```
        start
          ↓
    ┌─> PvP Mode ──┐
    │              │
    ├─> PvE Mode ──┤──> switchMode
    │              │
    └─> EvE Mode ──┘
```

**接口**：
```javascript
class ModeManager {
  constructor(gameState, aiEngine, ruleEngine) {
    this.state = gameState;
    this.ai = aiEngine;
    this.rules = ruleEngine;
    this.currentMode = 'PvP';
    this.eveAutoPlay = false;
  }

  setMode(mode) {
    // PvP | PvE | EvE
    this.currentMode = mode;
    this.state.mode = mode;
    this.emit('mode:changed', { mode });
  }

  async handleMove(x, y) {
    // 统一落子入口
    const validation = this.rules.validateMove(x, y);
    if (!validation.valid) {
      this.emit('move:invalid', validation);
      return;
    }

    this.state.applyMove({ x, y, player: this.state.currentPlayer });
    this.emit('move:completed', { x, y });

    // 检查胜负
    const winCheck = this.rules.checkWin(x, y, this.state.currentPlayer);
    if (winCheck.isWin) {
      this.finishGame(winCheck);
      return;
    }

    // 切换玩家
    this.state.switchPlayer();

    // PvE/EvE 模式下触发 AI
    if (this.shouldAIMove()) {
      await this.triggerAIMove();
    }
  }

  async triggerAIMove() {
    this.emit('ai:thinking', { player: this.state.currentPlayer });
    const move = await this.ai.computeMove(this.state.currentPlayer);
    await this.handleMove(move.x, move.y);
  }

  shouldAIMove() {
    if (this.currentMode === 'PvP') return false;
    if (this.currentMode === 'EvE') return true;
    if (this.currentMode === 'PvE') {
      // 判断当前玩家是否是 AI
      return this.state.currentPlayer === 2; // 假设白棋为 AI
    }
  }
}
```

---

## 数据流与状态管理

### 单向数据流
```
User Action / AI Move
        ↓
  ModeManager.handleMove()
        ↓
  RuleEngine.validateMove()
        ↓
  GameState.applyMove()
        ↓
  Event: 'state:changed'
        ↓
  CanvasRenderer.render()
        ↓
  HudPanel.updateStatus()
```

### 状态不可变更新
为保证数据一致性，所有状态更新应创建新的数据副本，避免直接修改：
```javascript
// ✅ 正确
this.board = this.board.map(row => [...row]);
this.board[y][x] = player;

// ❌ 错误
this.board[y][x] = player; // 直接修改可能导致副作用
```

---

## 事件与通信机制

### 事件总线设计
```javascript
class EventBus {
  constructor() {
    this.listeners = {};
  }

  on(event, handler) {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event].push(handler);
  }

  off(event, handler) {
    if (!this.listeners[event]) return;
    this.listeners[event] = this.listeners[event].filter(h => h !== handler);
  }

  emit(event, data) {
    if (!this.listeners[event]) return;
    this.listeners[event].forEach(handler => handler(data));
  }
}
```

### 核心事件列表
| 事件名 | 触发时机 | 数据 |
|--------|----------|------|
| `state:changed` | GameState 更新 | `{ state }` |
| `move:applied` | 落子成功 | `{ x, y, player }` |
| `move:invalid` | 落子失败 | `{ error, forbiddenInfo }` |
| `game:started` | 游戏开始 | `{ mode, settings }` |
| `game:finished` | 游戏结束 | `{ winner, winLine }` |
| `ai:thinking` | AI 开始计算 | `{ player, difficulty }` |
| `ai:moved` | AI 落子完成 | `{ x, y, score }` |
| `mode:changed` | 模式切换 | `{ mode }` |

---

## AI 引擎架构

### 策略工厂模式
```javascript
class StrategyFactory {
  constructor() {
    this.strategies = {
      BEGINNER: new BeginnerStrategy(),
      NORMAL: new NormalStrategy(),
      HARD: new HardStrategy(),
      HELL: new HellStrategy()
    };
  }

  get(level) {
    return this.strategies[level] || this.strategies.NORMAL;
  }
}
```

### 候选点生成（性能优化关键）
```javascript
class CandidateGenerator {
  generate(state) {
    const candidates = [];
    const radius = 2; // 仅考虑已有棋子周围 2 格范围

    for (let y = 0; y < state.boardSize; y++) {
      for (let x = 0; x < state.boardSize; x++) {
        if (state.board[y][x] !== 0) continue; // 跳过已有棋子
        
        const neighborCount = this.countNeighbors(state, x, y, radius);
        if (neighborCount > 0) {
          candidates.push({ x, y, priority: neighborCount });
        }
      }
    }

    // 按邻居数量排序，优先搜索热点区域
    return candidates.sort((a, b) => b.priority - a.priority);
  }
}
```

### 评分系统
```javascript
const SCORE_TABLE = {
  FIVE: 100000,
  OPEN_FOUR: 10000,
  CLOSED_FOUR: 1000,
  OPEN_THREE: 500,
  CLOSED_THREE: 100,
  OPEN_TWO: 50,
  CLOSED_TWO: 10,
  
  // 组合加分
  DOUBLE_OPEN_FOUR: 50000,
  FOUR_THREE_COMBO: 12000,
  DOUBLE_OPEN_THREE: 5000
};
```

---

## 渲染与 UI 架构

### Canvas 渲染优化
1. **分层渲染**：背景层（棋盘）、棋子层、特效层分离，减少重绘
2. **脏区域标记**：仅重绘变化区域
3. **离屏 Canvas**：复杂图形预渲染到离屏 Canvas
4. **requestAnimationFrame**：流畅动画

```javascript
class LayeredRenderer {
  constructor(canvasId) {
    this.mainCanvas = document.getElementById(canvasId);
    this.backgroundLayer = document.createElement('canvas');
    this.pieceLayer = document.createElement('canvas');
    this.effectLayer = document.createElement('canvas');
    
    this.needsBackgroundRedraw = true;
    this.needsPieceRedraw = true;
    this.needsEffectRedraw = true;
  }

  render() {
    if (this.needsBackgroundRedraw) {
      this.renderBackground();
      this.needsBackgroundRedraw = false;
    }
    
    if (this.needsPieceRedraw) {
      this.renderPieces();
      this.needsPieceRedraw = false;
    }
    
    if (this.needsEffectRedraw) {
      this.renderEffects();
      this.needsEffectRedraw = false;
    }
    
    this.composeLayers();
  }
}
```

---

## 存储与序列化

### 存档格式规范
```json
{
  "version": "2.0.0",
  "timestamp": 1704354567123,
  "mode": "PvE",
  "settings": {
    "boardSize": 15,
    "forbiddenRules": true,
    "aiDifficulty": "HARD"
  },
  "moves": [
    { "step": 1, "player": 1, "x": 7, "y": 7, "timestamp": 1704354567200 }
  ],
  "result": {
    "winner": 1,
    "reason": "five_in_row",
    "winLine": [{"x": 7, "y": 7}, {"x": 8, "y": 8}]
  }
}
```

### 版本兼容性处理
```javascript
class SaveLoadService {
  load(data) {
    const version = this.parseVersion(data.version);
    
    if (version.major === 1) {
      // 旧版本兼容逻辑
      return this.migrateV1ToV2(data);
    }
    
    return data;
  }

  migrateV1ToV2(oldData) {
    // 字段映射、默认值填充
    return {
      version: '2.0.0',
      ...oldData,
      settings: {
        ...oldData.settings,
        boardSize: oldData.settings.boardSize || 15
      }
    };
  }
}
```

---

## 模块加载与依赖管理

### 模块元信息规范
```javascript
const MODULE_INFO = {
  name: 'GameState',
  version: '2.0.0',
  author: '项目团队',
  dependencies: [], // 必需依赖
  optionalDependencies: ['Logger'] // 可选依赖
};

class GameState {
  static __moduleInfo = MODULE_INFO;
}

// 导出时触发事件
if (typeof window !== 'undefined') {
  window.GameState = GameState;
  window.dispatchEvent(new CustomEvent('moduleLoaded', {
    detail: MODULE_INFO
  }));
}
```

### 依赖检查工具
```javascript
class ModuleDependencyChecker {
  static checkDependencies() {
    const required = ['GameState', 'RuleEngine', 'AIEngine'];
    const missing = required.filter(name => !window[name]);
    
    if (missing.length > 0) {
      console.error('缺少必需模块:', missing);
      return false;
    }
    return true;
  }

  static logModuleInfo() {
    const modules = ['GameState', 'RuleEngine', 'AIEngine', 'CanvasRenderer'];
    modules.forEach(name => {
      const module = window[name];
      if (module && module.__moduleInfo) {
        console.log(`[${name}] v${module.__moduleInfo.version}`);
      }
    });
  }
}
```

---

## 扩展性设计

### 插件系统（未来扩展）
```javascript
class PluginManager {
  constructor() {
    this.plugins = [];
  }

  register(plugin) {
    if (this.validatePlugin(plugin)) {
      this.plugins.push(plugin);
      plugin.onInstall && plugin.onInstall();
    }
  }

  validatePlugin(plugin) {
    return plugin.name && plugin.version && typeof plugin.onInstall === 'function';
  }

  invoke(hook, ...args) {
    this.plugins.forEach(plugin => {
      if (plugin[hook]) {
        plugin[hook](...args);
      }
    });
  }
}

// 示例插件
const SoundPlugin = {
  name: 'SoundPlugin',
  version: '1.0.0',
  onInstall() {
    console.log('音效插件已安装');
  },
  onMoveApplied(move) {
    this.playSound('click.mp3');
  }
};
```

---

## 性能优化策略

### 1. AI 计算优化
- **Alpha-Beta 剪枝**：减少搜索节点
- **候选点限制**：仅搜索热点区域
- **迭代加深**：时间限制内尽可能深入搜索
- **开局库**：预存常见开局，跳过计算

### 2. 渲染优化
- **requestAnimationFrame**：避免不必要的重绘
- **Canvas 分层**：背景、棋子、特效独立渲染
- **节流防抖**：鼠标移动事件节流
- **离屏渲染**：复杂图形预渲染

### 3. 内存优化
- **对象池**：复用临时对象
- **弱引用**：避免内存泄漏
- **定期清理**：清除过期的事件监听器

### 4. 性能监控
```javascript
class PerformanceMonitor {
  static measure(name, fn) {
    const start = performance.now();
    const result = fn();
    const duration = performance.now() - start;
    console.log(`[性能] ${name}: ${duration.toFixed(2)}ms`);
    return result;
  }
}
```

---

## 总结

本架构设计文档为 H5 五子棋项目提供了**清晰的模块划分**、**数据流管理**、**事件通信机制**和**性能优化策略**。核心设计原则包括：

1. **职责分离**：数据、逻辑、渲染、服务独立
2. **事件驱动**：模块间通过事件总线松耦合
3. **单向数据流**：状态不可变更新，可预测性高
4. **可扩展性**：插件系统、策略模式支持未来扩展
5. **高性能**：分层渲染、候选点优化、Alpha-Beta 剪枝

所有模块需遵循本文档的接口规范，确保系统的**一致性**与**可维护性**。
