# H5 五子棋开发建议与最佳实践

> 版本：1.0  
> 适用对象：开发团队、架构评审、AI 代码生成  
> 目标：提供高质量可落地的实践指南，避免旧项目的技术债务

---

## 1. 代码规范与风格

### 1.1 命名约定
| 类型 | 规则 | 示例 |
|------|------|------|
| 类名 | PascalCase | `GameState`, `RuleEngine` |
| 方法/函数 | camelCase | `applyMove()`, `checkWin()` |
| 常量 | UPPER_SNAKE_CASE | `BOARD_SIZE`, `SCORE_TABLE` |
| 私有成员 | 下划线前缀 | `_internalState`, `_validateInput()` |

### 1.2 文件组织
```
js/
  ├── core/
  │   ├── GameState.js        # 类名与文件名一致
  │   ├── RuleEngine.js
  │   └── ...
  ├── ui/
  │   ├── CanvasRenderer.js
  │   └── HudPanel.js
  └── services/
      ├── SaveLoadService.js
      └── ...
```

### 1.3 JSDoc 注释规范
```javascript
/**
 * 落子并更新游戏状态
 * @param {Object} move - 落子对象
 * @param {number} move.x - X坐标 (0-14)
 * @param {number} move.y - Y坐标 (0-14)
 * @param {number} move.player - 玩家标识 (1=黑, 2=白)
 * @returns {{success: boolean, error?: string, gameOver?: boolean}}
 * @throws {Error} 若坐标超出范围
 */
applyMove(move) {
  // 实现
}
```

---

## 2. 模块化与依赖管理

### 2.1 模块导出规范
```javascript
// 示例：GameState.js
class GameState {
  constructor() {
    // 初始化
  }
}

// 模块元信息
GameState.__moduleInfo = {
  name: 'GameState',
  version: '2.0.0',
  author: '项目团队',
  dependencies: [],
  optionalDependencies: ['Logger']
};

// 导出到全局
if (typeof window !== 'undefined') {
  window.GameState = GameState;
  
  // 触发模块加载事件
  window.dispatchEvent(new CustomEvent('moduleLoaded', {
    detail: GameState.__moduleInfo
  }));
}

// 支持 CommonJS（可选）
if (typeof module !== 'undefined' && module.exports) {
  module.exports = GameState;
}
```

### 2.2 依赖注入（推荐）
```javascript
// ❌ 避免全局依赖
class ModeManager {
  constructor() {
    this.state = window.gameState; // 全局变量耦合
  }
}

// ✅ 依赖注入
class ModeManager {
  constructor(gameState, aiEngine, ruleEngine) {
    this.state = gameState;
    this.ai = aiEngine;
    this.rules = ruleEngine;
  }
}
```

### 2.3 模块加载顺序
```html
<!-- 按依赖层级加载 -->
<script src="js/utils/EventBus.js"></script>
<script src="js/utils/Logger.js"></script>
<script src="js/core/GameState.js"></script>
<script src="js/core/RuleEngine.js"></script>
<script src="js/core/AIEngine.js"></script>
<script src="js/ui/CanvasRenderer.js"></script>
<script src="js/ui/HudPanel.js"></script>
<script src="js/services/SaveLoadService.js"></script>
<script src="js/services/ReplayService.js"></script>
<script src="js/app/ModeManager.js"></script>
<script src="js/main.js"></script> <!-- 入口文件最后加载 -->
```

---

## 3. 状态管理最佳实践

### 3.1 单一数据源
```javascript
// ✅ 所有状态集中在 GameState
class GameState {
  constructor() {
    this.board = Array(15).fill().map(() => Array(15).fill(0));
    this.currentPlayer = 1;
    this.moveHistory = [];
    this.gameStatus = 'ready';
    // ...
  }
}

// ❌ 避免分散状态
let currentPlayer = 1; // 全局变量
let board = [...]; // 分散管理
```

### 3.2 不可变更新
```javascript
// ✅ 创建新副本
updateBoard(x, y, player) {
  this.board = this.board.map((row, rowIndex) => 
    rowIndex === y ? row.map((cell, colIndex) => 
      colIndex === x ? player : cell
    ) : row
  );
}

// ❌ 直接修改可能导致副作用
updateBoard(x, y, player) {
  this.board[y][x] = player;
}
```

### 3.3 快照与恢复
```javascript
getSnapshot() {
  return JSON.parse(JSON.stringify({
    board: this.board,
    currentPlayer: this.currentPlayer,
    moveHistory: this.moveHistory,
    gameStatus: this.gameStatus
    // ...
  }));
}

restoreSnapshot(snapshot) {
  Object.assign(this, JSON.parse(JSON.stringify(snapshot)));
}
```

---

## 4. 事件驱动设计

### 4.1 事件总线实现
```javascript
class EventBus {
  constructor() {
    this.listeners = {};
  }

  on(event, handler) {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event].push(handler);
    return () => this.off(event, handler); // 返回取消订阅函数
  }

  off(event, handler) {
    if (!this.listeners[event]) return;
    this.listeners[event] = this.listeners[event].filter(h => h !== handler);
  }

  emit(event, data) {
    if (!this.listeners[event]) return;
    this.listeners[event].forEach(handler => {
      try {
        handler(data);
      } catch (error) {
        console.error(`事件处理错误 [${event}]:`, error);
      }
    });
  }
}
```

### 4.2 事件命名规范
- 使用命名空间：`state:changed`、`move:applied`、`ai:thinking`
- 使用现在时：`move:completed`（而非 `move:complete`）
- 语义清晰：避免缩写，使用完整单词

### 4.3 解耦示例
```javascript
// ModeManager 触发事件
class ModeManager {
  handleMove(x, y) {
    // ...
    this.eventBus.emit('move:applied', { x, y, player });
  }
}

// CanvasRenderer 订阅事件
class CanvasRenderer {
  constructor(eventBus) {
    this.eventBus = eventBus;
    this.eventBus.on('move:applied', (data) => {
      this.render();
    });
  }
}
```

---

## 5. 错误处理与日志

### 5.1 统一日志工具
```javascript
class Logger {
  static levels = { DEBUG: 0, INFO: 1, WARN: 2, ERROR: 3 };
  static currentLevel = Logger.levels.INFO;

  static debug(module, message, data) {
    if (this.currentLevel > this.levels.DEBUG) return;
    console.debug(`[${module}]`, message, data || '');
  }

  static info(module, message, data) {
    if (this.currentLevel > this.levels.INFO) return;
    console.log(`[${module}]`, message, data || '');
  }

  static warn(module, message, data) {
    if (this.currentLevel > this.levels.WARN) return;
    console.warn(`[${module}]`, message, data || '');
  }

  static error(module, message, error) {
    console.error(`[${module}]`, message, error);
  }
}

// 使用示例
Logger.info('GameCore', '落子成功', { x: 7, y: 7 });
Logger.error('AIEngine', 'AI计算失败', error);
```

### 5.2 防御性编程
```javascript
// ✅ 输入验证
applyMove(move) {
  if (!move || typeof move.x !== 'number' || typeof move.y !== 'number') {
    throw new Error('Invalid move object');
  }
  
  if (move.x < 0 || move.x >= this.boardSize || move.y < 0 || move.y >= this.boardSize) {
    throw new Error(`Coordinates out of range: (${move.x}, ${move.y})`);
  }
  
  // 继续处理
}

// ✅ 空值检查
if (window.game && typeof window.game.placePiece === 'function') {
  window.game.placePiece(x, y);
} else {
  Logger.error('BoardRenderer', '游戏核心未加载');
}
```

### 5.3 错误恢复策略
```javascript
// 尝试保存存档失败时的处理
try {
  this.saveGame(snapshot);
  Logger.info('SaveLoad', '保存成功');
} catch (error) {
  Logger.error('SaveLoad', '保存失败', error);
  this.showUserMessage('保存失败，请检查浏览器设置', 'error');
  // 降级方案：提示用户手动导出
  this.promptManualExport(snapshot);
}
```

---

## 6. 性能优化实践

### 6.1 Canvas 渲染优化
```javascript
// ✅ 分层渲染
class LayeredRenderer {
  constructor() {
    this.backgroundCanvas = document.createElement('canvas');
    this.pieceCanvas = document.createElement('canvas');
    this.effectCanvas = document.createElement('canvas');
    
    this.backgroundDirty = true;
    this.pieceDirty = true;
    this.effectDirty = true;
  }

  render() {
    if (this.backgroundDirty) {
      this.renderBackground();
      this.backgroundDirty = false;
    }
    
    if (this.pieceDirty) {
      this.renderPieces();
      this.pieceDirty = false;
    }
    
    if (this.effectDirty) {
      this.renderEffects();
      this.effectDirty = false;
    }
    
    this.composeLayers();
  }
}
```

### 6.2 候选点优化
```javascript
// ✅ 限制候选范围
generateCandidates(state) {
  const candidates = new Set();
  const radius = 2;
  
  // 仅在已有棋子周围生成
  for (let y = 0; y < state.boardSize; y++) {
    for (let x = 0; x < state.boardSize; x++) {
      if (state.board[y][x] === 0) continue;
      
      for (let dy = -radius; dy <= radius; dy++) {
        for (let dx = -radius; dx <= radius; dx++) {
          const nx = x + dx, ny = y + dy;
          if (this.isValid(nx, ny) && state.board[ny][nx] === 0) {
            candidates.add(`${nx},${ny}`);
          }
        }
      }
    }
  }
  
  return Array.from(candidates).map(pos => {
    const [x, y] = pos.split(',').map(Number);
    return { x, y };
  });
}
```

### 6.3 节流与防抖
```javascript
// 节流：鼠标移动事件
canvas.addEventListener('mousemove', throttle((e) => {
  this.handleMouseMove(e);
}, 16)); // 60fps

// 防抖：窗口大小调整
window.addEventListener('resize', debounce(() => {
  this.resizeCanvas();
}, 300));

function throttle(fn, delay) {
  let lastCall = 0;
  return function(...args) {
    const now = Date.now();
    if (now - lastCall >= delay) {
      lastCall = now;
      fn.apply(this, args);
    }
  };
}

function debounce(fn, delay) {
  let timer;
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => fn.apply(this, args), delay);
  };
}
```

---

## 7. 测试策略

### 7.1 单元测试示例（Vitest/Jest）
```javascript
import { describe, it, expect, beforeEach } from 'vitest';
import GameState from '../core/GameState.js';
import RuleEngine from '../core/RuleEngine.js';

describe('RuleEngine - 禁手检测', () => {
  let state, rules;

  beforeEach(() => {
    state = new GameState();
    rules = new RuleEngine(state);
  });

  it('应检测三三禁手', () => {
    // 构建棋局：形成两个活三
    state.setPiece(6, 7, 1);
    state.setPiece(8, 7, 1);
    state.setPiece(7, 6, 1);
    state.setPiece(7, 8, 1);

    const result = rules.detectForbidden(7, 7);
    expect(result.isForbidden).toBe(true);
    expect(result.type).toBe('三三禁手');
  });

  it('白棋不应受禁手限制', () => {
    state.setPiece(6, 7, 2);
    state.setPiece(8, 7, 2);
    state.setPiece(7, 6, 2);
    state.setPiece(7, 8, 2);

    const result = rules.detectForbidden(7, 7);
    expect(result.isForbidden).toBe(false);
  });
});
```

### 7.2 集成测试思路
```javascript
describe('完整对局流程', () => {
  it('应完成一局 PvP 游戏', async () => {
    const app = new GameApp();
    app.initialize();
    
    // 模拟落子序列
    const moves = [
      { x: 7, y: 7 }, { x: 7, y: 8 },
      { x: 8, y: 7 }, { x: 8, y: 8 },
      // ...
    ];
    
    for (const move of moves) {
      await app.handleMove(move.x, move.y);
    }
    
    expect(app.state.gameStatus).toBe('finished');
    expect(app.state.winner).toBe(1);
  });
});
```

### 7.3 性能基准测试
```javascript
describe('性能基准', () => {
  it('禁手检测应小于 5ms', () => {
    const state = new GameState();
    const rules = new RuleEngine(state);
    
    const start = performance.now();
    for (let i = 0; i < 1000; i++) {
      rules.detectForbidden(7, 7);
    }
    const avgTime = (performance.now() - start) / 1000;
    
    expect(avgTime).toBeLessThan(5);
  });
});
```

---

## 8. 调试技巧

### 8.1 开发者工具集成
```javascript
// 全局调试对象
window.GomokuDebug = {
  state: null,
  rules: null,
  ai: null,
  renderer: null,
  
  init(app) {
    this.state = app.state;
    this.rules = app.rules;
    this.ai = app.ai;
    this.renderer = app.renderer;
    console.log('调试工具已启用。使用 GomokuDebug.help() 查看帮助');
  },
  
  help() {
    console.log(`
      可用命令：
      - GomokuDebug.logState()          # 打印当前状态
      - GomokuDebug.logBoard()          # 表格显示棋盘
      - GomokuDebug.testForbidden(x, y) # 测试禁手检测
      - GomokuDebug.getAIMove()         # 获取 AI 建议
      - GomokuDebug.logModules()        # 查看模块信息
    `);
  },
  
  logBoard() {
    console.table(this.state.board);
  },
  
  testForbidden(x, y) {
    const result = this.rules.detectForbidden(x, y);
    console.log('禁手检测结果:', result);
    return result;
  }
};
```

### 8.2 Canvas 可视化调试
```javascript
// 绘制调试信息
renderDebugInfo() {
  if (!this.debugMode) return;
  
  // 显示候选点
  this.candidates.forEach(c => {
    const pos = this.gridToScreen(c.x, c.y);
    this.ctx.fillStyle = 'rgba(0,255,0,0.3)';
    this.ctx.fillRect(pos.x - 5, pos.y - 5, 10, 10);
    this.ctx.fillStyle = 'black';
    this.ctx.fillText(c.score, pos.x + 10, pos.y);
  });
}
```

---

## 9. 代码审查检查清单

- [ ] 模块职责单一，无全局变量污染
- [ ] 所有公共方法有 JSDoc 注释
- [ ] 输入参数有验证，错误有日志
- [ ] 使用事件总线而非直接调用跨层模块
- [ ] 关键算法有单元测试覆盖
- [ ] 性能敏感代码有优化（候选点、Canvas）
- [ ] 无硬编码魔法数字，使用常量
- [ ] 遵守命名规范与代码风格
- [ ] 无 TODO / FIXME 残留（需在 Issue 中跟踪）

---

## 10. 常见陷阱与避免策略

| 陷阱 | 后果 | 避免方式 |
|------|------|----------|
| 直接修改状态 | 数据不一致、难以调试 | 使用不可变更新、快照机制 |
| 全局变量耦合 | 测试困难、扩展性差 | 依赖注入、事件驱动 |
| 过度优化 | 代码复杂、难以维护 | 先保证正确性，再优化瓶颈 |
| 缺少错误处理 | 运行时崩溃 | try-catch + 日志 + 用户提示 |
| 魔法数字 | 可读性差、难以维护 | 提取为命名常量 |
| 缺少注释 | 接手困难 | JSDoc + 关键逻辑注释 |

---

## 11. 推荐资源

- **Canvas 性能优化**：MDN Canvas Best Practices
- **五子棋 AI 理论**：Victor Allis Threat-Space Search
- **JavaScript 设计模式**：《Learning JavaScript Design Patterns》
- **可访问性指南**：WCAG 2.1 标准、ARIA 最佳实践
- **测试指南**：Vitest 文档、Jest 最佳实践

---

> 本文档汇总了高质量代码开发的核心要点，所有开发者应在编码前阅读，并在 Code Review 时对照检查。